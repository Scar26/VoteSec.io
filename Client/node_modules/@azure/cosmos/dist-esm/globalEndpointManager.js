import * as tslib_1 from "tslib";
import { Constants, sleep } from "./common";
import { LocationCache } from "./LocationCache";
/**
 * @hidden
 * This internal class implements the logic for endpoint management for geo-replicated database accounts.
 * @property {object} client                       - The document client instance.
 * @property {string} defaultEndpoint              - The endpoint used to create the client instance.
 * @property {bool} enableEndpointDiscovery        - Flag to enable/disable automatic redirecting of requests
 *                                                   based on read/write operations.
 * @property {Array} preferredLocations            - List of azure regions to be used as preferred locations
 *                                                   for read requests.
 * @property {bool} isEndpointCacheInitialized     - Flag to determine whether the endpoint cache is initialized or not.
 */
export class GlobalEndpointManager {
    /**
     * @constructor GlobalEndpointManager
     * @param {object} options                          - The document client instance.
     */
    constructor(options, readDatabaseAccount) {
        this.readDatabaseAccount = readDatabaseAccount;
        this.defaultEndpoint = options.endpoint;
        this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;
        this.isEndpointCacheInitialized = false;
        this.locationCache = new LocationCache(options);
        this.isRefreshing = false;
        this.backgroundRefreshTimeIntervalInMS = Constants.DefaultUnavailableLocationExpirationTimeMS;
    }
    /**
     * Gets the current read endpoint from the endpoint cache.
     */
    getReadEndpoint() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.isEndpointCacheInitialized) {
                yield this.refreshEndpointList();
            }
            return this.locationCache.getReadEndpoint();
        });
    }
    /**
     * Gets the current write endpoint from the endpoint cache.
     */
    getWriteEndpoint() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.isEndpointCacheInitialized) {
                yield this.refreshEndpointList();
            }
            return this.locationCache.getWriteEndpoint();
        });
    }
    getReadEndpoints() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.isEndpointCacheInitialized) {
                yield this.refreshEndpointList();
            }
            return this.locationCache.getReadEndpoints();
        });
    }
    getWriteEndpoints() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.isEndpointCacheInitialized) {
                yield this.refreshEndpointList();
            }
            return this.locationCache.getWriteEndpoints();
        });
    }
    markCurrentLocationUnavailableForRead(endpoint) {
        this.locationCache.markCurrentLocationUnavailableForRead(endpoint);
    }
    markCurrentLocationUnavailableForWrite(endpoint) {
        this.locationCache.markCurrentLocationUnavailableForWrite(endpoint);
    }
    canUseMultipleWriteLocations(resourceType, operationType) {
        return this.locationCache.canUseMultipleWriteLocations(resourceType, operationType);
    }
    resolveServiceEndpoint(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.isEndpointCacheInitialized) {
                yield this.refreshEndpointList();
            }
            return this.locationCache.resolveServiceEndpoint(request);
        });
    }
    /**
     * Refreshes the endpoint list by retrieving the writable and readable locations
     *  from the geo-replicated database account and then updating the locations cache.
     *   We skip the refreshing if enableEndpointDiscovery is set to False
     */
    refreshEndpointList() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.isRefreshing && this.enableEndpointDiscovery) {
                this.isRefreshing = true;
                let shouldRefresh = false;
                const databaseAccount = yield this.getDatabaseAccountFromAnyEndpoint();
                if (databaseAccount) {
                    this.locationCache.onDatabaseAccountRead(databaseAccount);
                }
                ({ shouldRefresh } = this.locationCache.shouldRefreshEndpoints());
                if (shouldRefresh) {
                    this.backgroundRefresh();
                    return;
                }
                else {
                    this.isRefreshing = false;
                    this.isEndpointCacheInitialized = true;
                }
            }
        });
    }
    backgroundRefresh() {
        process.nextTick(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.isRefreshing = true;
            let shouldRefresh = false;
            try {
                do {
                    const databaseAccount = yield this.getDatabaseAccountFromAnyEndpoint();
                    if (databaseAccount) {
                        this.locationCache.onDatabaseAccountRead(databaseAccount);
                    }
                    ({ shouldRefresh } = this.locationCache.shouldRefreshEndpoints());
                    if (!shouldRefresh) {
                        break;
                    }
                    yield sleep(this.backgroundRefreshTimeIntervalInMS);
                } while (shouldRefresh);
            }
            catch (err) {
                /* swallow error */
                // TODO: Tracing
            }
            this.isRefreshing = false;
            this.isEndpointCacheInitialized = true;
        }));
    }
    /**
     * Gets the database account first by using the default endpoint, and if that doesn't returns
     * use the endpoints for the preferred locations in the order they are specified to get
     * the database account.
     * @memberof GlobalEndpointManager
     * @instance
     * @param {function} callback        - The callback function which takes databaseAccount(object) as an argument.
     */
    getDatabaseAccountFromAnyEndpoint() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const options = { urlConnection: this.defaultEndpoint };
                const { resource: databaseAccount } = yield this.readDatabaseAccount(options);
                return databaseAccount;
                // If for any reason(non - globaldb related), we are not able to get the database
                // account from the above call to readDatabaseAccount,
                // we would try to get this information from any of the preferred locations that the user
                // might have specified (by creating a locational endpoint)
                // and keeping eating the exception until we get the database account and return None at the end,
                // if we are not able to get that info from any endpoints
            }
            catch (err) {
                // TODO: Tracing
            }
            if (this.locationCache.prefferredLocations) {
                for (const location of this.locationCache.prefferredLocations) {
                    try {
                        const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(this.defaultEndpoint, location);
                        const options = { urlConnection: locationalEndpoint };
                        const { resource: databaseAccount } = yield this.readDatabaseAccount(options);
                        if (databaseAccount) {
                            return databaseAccount;
                        }
                    }
                    catch (err) {
                        // TODO: Tracing
                    }
                }
            }
        });
    }
    /**
     * Gets the locational endpoint using the location name passed to it using the default endpoint.
     * @memberof GlobalEndpointManager
     * @instance
     * @param {string} defaultEndpoint - The default endpoint to use for the endpoint.
     * @param {string} locationName    - The location name for the azure region like "East US".
     */
    static getLocationalEndpoint(defaultEndpoint, locationName) {
        // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format
        // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)
        // and we agreed to document that
        const endpointUrl = new URL(defaultEndpoint);
        // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'
        if (endpointUrl.hostname) {
            const hostnameParts = endpointUrl.hostname
                .toString()
                .toLowerCase()
                .split(".");
            if (hostnameParts) {
                // globalDatabaseAccountName will return 'contoso'
                const globalDatabaseAccountName = hostnameParts[0];
                // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'
                const locationalDatabaseAccountName = globalDatabaseAccountName + "-" + locationName.replace(" ", "");
                // Replace 'contoso' with 'contoso-EastUS' and
                // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/
                const locationalEndpoint = defaultEndpoint
                    .toLowerCase()
                    .replace(globalDatabaseAccountName, locationalDatabaseAccountName);
                return locationalEndpoint;
            }
        }
        return null;
    }
}
//# sourceMappingURL=globalEndpointManager.js.map